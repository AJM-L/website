{"version":3,"file":"static/js/501.c5159a6f.chunk.js","mappings":"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","sources":["components/About/TextSphere.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst TextSphere = ({ \n    text, \n    position = [0, 0, 0],\n    radius = 5,\n    vertexCount = 50,\n    spinSpeed = 0.005,\n    lightIntensity = 1.0,\n    lightPosition = [10, 10, 10],\n    fontThickness = 0.1,\n    link = null // Optional link to navigate to\n}) => {\n    const navigate = useNavigate();\n    const mountRef = useRef(null);\n    const animationFrameRef = useRef(null);\n    const sceneRef = useRef(null);\n    const textGroupRef = useRef(null);\n    const cameraRef = useRef(null);\n    const [threeLoaded, setThreeLoaded] = useState(false);\n    const [error, setError] = useState(null);\n    const [isHovered, setIsHovered] = useState(false);\n    const THREE_REF = useRef(null);\n    const mousePositionRef = useRef({ x: 0, y: 0 });\n    const sphereCenterRef = useRef({ x: 0, y: 0 });\n    \n    // Animation targets for smooth transitions\n    const targetCameraDistance = useRef(radius * 3);\n    const currentCameraDistance = useRef(radius * 3);\n    const targetRadius = useRef(radius);\n    const currentRadius = useRef(radius);\n\n    useEffect(() => {\n        // Dynamically import three.js to avoid build-time processing\n        import('three').then((THREE_MODULE) => {\n            // Handle different export formats\n            const THREE = THREE_MODULE.default || THREE_MODULE;\n            if (THREE && THREE.Scene) {\n                THREE_REF.current = THREE;\n                setThreeLoaded(true);\n            } else {\n                setError('Failed to load Three.js module');\n            }\n        }).catch((err) => {\n            setError('Failed to load Three.js - ' + err.message);\n        });\n    }, []);\n\n    useEffect(() => {\n        if (!threeLoaded || !THREE_REF.current || !mountRef.current) {\n            return;\n        }\n        \n        const THREE = THREE_REF.current;\n        if (!mountRef.current || !THREE) {\n            return;\n        }\n        \n        let renderer = null;\n        let camera = null;\n        let scene = null;\n        let textGroup = null;\n        let directionalLightRef = null;\n        // Store lighting parameters for animation loop\n        const currentLightIntensity = lightIntensity;\n        const currentLightPosition = [...lightPosition];\n        const currentFontThickness = fontThickness;\n        // Store initial values for hover animation\n        const initialRadius = radius;\n        const initialCameraDistance = Math.max(radius * 3, 15);\n\n        // Scene setup\n        scene = new THREE.Scene();\n        scene.background = null; // Transparent background\n        sceneRef.current = scene;\n\n        const aspect = mountRef.current.clientWidth / mountRef.current.clientHeight || 1;\n        camera = new THREE.PerspectiveCamera(\n            75,\n            aspect,\n            0.1,\n            1000\n        );\n        // Position camera to view the sphere - make sure it's far enough back\n        // Position camera to look at the textGroup position\n        const cameraDistance = initialCameraDistance;\n        currentCameraDistance.current = cameraDistance;\n        targetCameraDistance.current = cameraDistance;\n        camera.position.z = position[2] + cameraDistance;\n        camera.position.y = position[1];\n        camera.position.x = position[0];\n        camera.lookAt(position[0], position[1], position[2]);\n        cameraRef.current = camera;\n        \n        // Calculate sphere center in screen coordinates (center of container)\n        // This will be updated on mouse move and resize\n        if (mountRef.current) {\n            const rect = mountRef.current.getBoundingClientRect();\n            sphereCenterRef.current = {\n                x: rect.left + rect.width / 2,\n                y: rect.top + rect.height / 2\n            };\n        }\n\n        renderer = new THREE.WebGLRenderer({ \n            antialias: true, \n            alpha: true,\n            powerPreference: \"high-performance\"\n        });\n        renderer.setClearColor(0x000000, 0); // Transparent background\n        // Use container size - canvas should match container to avoid scaling issues\n        const baseWidth = mountRef.current.clientWidth || 800;\n        const baseHeight = mountRef.current.clientHeight || 800;\n        // Canvas matches container size - container is already sized for expansion\n        const width = baseWidth;\n        const height = baseHeight;\n        renderer.setSize(width, height);\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Lower pixel ratio for better performance\n        \n        // Make sure canvas is visible and can overflow - center it in container\n        renderer.domElement.style.width = width + 'px';\n        renderer.domElement.style.height = height + 'px';\n        renderer.domElement.style.display = 'block';\n        renderer.domElement.style.overflow = 'visible';\n        renderer.domElement.style.position = 'absolute';\n        renderer.domElement.style.top = '50%';\n        renderer.domElement.style.left = '50%';\n        renderer.domElement.style.transform = 'translate(-50%, -50%)';\n        renderer.domElement.style.pointerEvents = 'auto';\n        renderer.domElement.style.maxWidth = 'none';\n        renderer.domElement.style.maxHeight = 'none';\n        \n        if (mountRef.current) {\n            mountRef.current.appendChild(renderer.domElement);\n        }\n\n        // Lighting setup for diffuse lighting - reduce ambient to make directional light more visible\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);\n        scene.add(ambientLight);\n\n        const directionalLight = new THREE.DirectionalLight(\n            0xffffff, \n            lightIntensity * 2.0\n        );\n        directionalLight.position.set(...lightPosition);\n        scene.add(directionalLight);\n        directionalLightRef = directionalLight; // Store reference for animation loop\n\n        // Add a point light for more dynamic lighting\n        const pointLight = new THREE.PointLight(0xffffff, 1.5);\n        pointLight.position.set(5, 5, 5);\n        scene.add(pointLight);\n        \n        // Add another light from the front\n        const frontLight = new THREE.DirectionalLight(0xffffff, 1.2);\n        frontLight.position.set(0, 0, 10);\n        scene.add(frontLight);\n\n        // Create text group\n        textGroup = new THREE.Group();\n        textGroupRef.current = textGroup;\n        currentRadius.current = initialRadius;\n        targetRadius.current = initialRadius;\n\n        // Create text using canvas and position words in sphere pattern\n        const createTextSphere = () => {\n            // Split text into words\n            const words = text.split(' ').filter(w => w.length > 0);\n            const totalWords = words.length;\n            \n            if (totalWords === 0) return;\n            \n            // Repeat the phrase multiple times to fill the sphere\n            // Calculate how many instances we need based on desired density\n            const instancesPerWord = Math.max(8, Math.floor(70 / totalWords)); // Reduced density for better readability\n            const totalInstances = totalWords * instancesPerWord;\n            \n            // Use Fibonacci sphere distribution for even spacing\n            const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle\n            \n            // Create instances of each word distributed around the sphere\n            for (let instanceIndex = 0; instanceIndex < totalInstances; instanceIndex++) {\n                // Cycle through words\n                const wordIndex = instanceIndex % totalWords;\n                const word = words[wordIndex];\n                \n                // Calculate position on sphere for each instance\n                const y = 1 - (instanceIndex / (totalInstances - 1)) * 2; // y from 1 to -1\n                const radius_at_y = Math.sqrt(Math.max(0, 1 - y * y));\n                const theta = phi * instanceIndex;\n                \n                const x = Math.cos(theta) * radius_at_y;\n                const z = Math.sin(theta) * radius_at_y;\n                \n                // Create canvas for entire word\n                const canvas = document.createElement('canvas');\n                const context = canvas.getContext('2d');\n                canvas.width = 512;\n                canvas.height = 512;\n                \n                // Fill with transparent background\n                context.fillStyle = 'rgba(0, 0, 0, 0)';\n                context.fillRect(0, 0, canvas.width, canvas.height);\n                \n                // Draw word - make it larger and more visible with high contrast\n                const fontSize = Math.max(100, Math.min(180, 500 / word.length));\n                context.fillStyle = '#ffffff';\n                context.font = `Bold ${fontSize}px Arial`;\n                context.textAlign = 'center';\n                context.textBaseline = 'middle';\n                // Strong black stroke for high contrast\n                context.strokeStyle = '#000000';\n                context.lineWidth = 5;\n                context.strokeText(word, 256, 256);\n                context.fillText(word, 256, 256);\n                \n                // Create texture from canvas\n                const texture = new THREE.CanvasTexture(canvas);\n                texture.needsUpdate = true;\n                \n                // Create plane geometry for each word with vertex count control\n                const segments = Math.max(1, Math.floor(Math.sqrt(vertexCount)));\n                // Make planes larger for better visibility - scale based on radius and word length\n                const planeWidth = Math.max(radius * 0.7, word.length * 0.4);\n                const planeHeight = radius * 0.6;\n                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight, segments, segments);\n                \n                // Create material with diffuse lighting and high contrast\n                // The lighting will affect how thick the text appears\n                const material = new THREE.MeshStandardMaterial({\n                    map: texture,\n                    transparent: true,\n                    alphaTest: 0.05, // Discard pixels with low alpha\n                    side: THREE.DoubleSide, // Render both sides\n                    emissive: 0x444444, // Increased emission for better visibility\n                    metalness: 0.0,\n                    roughness: 0.5\n                });\n                \n                const mesh = new THREE.Mesh(geometry, material);\n                \n                // Position on sphere\n                const posX = x * radius;\n                const posY = y * radius;\n                const posZ = z * radius;\n                mesh.position.set(posX, posY, posZ);\n                \n                // Store reference to camera for billboard effect\n                mesh.userData.isBillboard = true;\n                // Store initial scale for lighting-based scaling\n                mesh.userData.initialScale = { x: 1, y: 1, z: 1 };\n                \n                textGroup.add(mesh);\n            }\n        };\n\n        // Use canvas method immediately (no external resources needed)\n        createTextSphere();\n\n        textGroup.position.set(...position);\n        scene.add(textGroup);\n\n        // Animation loop\n        const animate = () => {\n            animationFrameRef.current = requestAnimationFrame(animate);\n            \n            if (textGroupRef.current && camera && scene) {\n                // Smooth camera distance transition on hover\n                const cameraLerpSpeed = 0.1;\n                currentCameraDistance.current += (targetCameraDistance.current - currentCameraDistance.current) * cameraLerpSpeed;\n                \n                // Update camera position based on hover state\n                if (cameraRef.current) {\n                    const newDistance = currentCameraDistance.current;\n                    cameraRef.current.position.z = position[2] + newDistance;\n                    cameraRef.current.position.y = position[1];\n                    cameraRef.current.position.x = position[0];\n                    cameraRef.current.lookAt(position[0], position[1], position[2]);\n                }\n                \n                // Smooth radius transition on hover\n                const radiusLerpSpeed = 0.1;\n                currentRadius.current += (targetRadius.current - currentRadius.current) * radiusLerpSpeed;\n                \n                // Scale the entire text group based on hover\n                const scaleFactor = currentRadius.current / initialRadius;\n                textGroupRef.current.scale.set(scaleFactor, scaleFactor, scaleFactor);\n                \n                // Rotate the entire group\n                textGroupRef.current.rotation.y += spinSpeed;\n                textGroupRef.current.rotation.x += spinSpeed * 0.5;\n                \n                // Make each word face the camera and scale based on lighting\n                textGroupRef.current.children.forEach((child) => {\n                    if (child.userData.isBillboard) {\n                        // Get world position of the mesh\n                        const worldPos = new THREE.Vector3();\n                        child.getWorldPosition(worldPos);\n                        \n                        // Make the mesh look at the camera\n                        child.lookAt(camera.position);\n                        \n                        // Calculate lighting intensity at this position based on sphere surface\n                        // Get the direction from sphere center to mesh (surface normal)\n                        const meshWorldPos = new THREE.Vector3();\n                        child.getWorldPosition(meshWorldPos);\n                        const textGroupWorldPos = new THREE.Vector3();\n                        textGroupRef.current.getWorldPosition(textGroupWorldPos);\n                        \n                        // Surface normal points from sphere center to mesh\n                        const surfaceNormal = new THREE.Vector3()\n                            .subVectors(meshWorldPos, textGroupWorldPos)\n                            .normalize();\n                        \n                        // For directional light, the direction is the negative of the position\n                        // Directional lights shine in the direction opposite to their position\n                        const lightDirection = new THREE.Vector3(...currentLightPosition).normalize().negate();\n                        \n                        // Calculate dot product (how much the surface faces the light)\n                        // Positive = facing light, negative = facing away\n                        const lightIntensityFactor = Math.max(0, Math.min(1, surfaceNormal.dot(lightDirection)));\n                        \n                        // Scale based on light intensity - brighter areas = larger text\n                        // Make the effect more pronounced with a wider range\n                        const minScale = 0.2; // Minimum scale for shadowed areas\n                        const maxScale = 4; // Maximum scale for fully lit areas\n                        const scaleRange = maxScale - minScale;\n                        const finalScale = minScale + (lightIntensityFactor * scaleRange * currentLightIntensity * currentFontThickness);\n                        \n                        // Apply scale to make text appear thicker where lit\n                        child.scale.set(finalScale, finalScale, 1);\n                        \n                        // Also adjust material emissive based on lighting for color variation\n                        if (child.material && child.material.emissive) {\n                            const emissiveIntensity = lightIntensityFactor * 0.3;\n                            child.material.emissive.setRGB(emissiveIntensity, emissiveIntensity, emissiveIntensity);\n                        }\n                    }\n                });\n            }\n            \n            if (renderer && scene && camera) {\n                renderer.render(scene, camera);\n            }\n        };\n        animate();\n\n        // Handle resize - canvas matches container size with debouncing for performance\n        let resizeTimeout;\n        const handleResize = () => {\n            if (!mountRef.current || !camera || !renderer) return;\n            clearTimeout(resizeTimeout);\n            resizeTimeout = setTimeout(() => {\n                const baseWidth = mountRef.current.clientWidth || 800;\n                const baseHeight = mountRef.current.clientHeight || 800;\n                const width = baseWidth;\n                const height = baseHeight;\n                camera.aspect = (baseWidth / baseHeight);\n                camera.updateProjectionMatrix();\n                renderer.setSize(width, height);\n                renderer.domElement.style.width = width + 'px';\n                renderer.domElement.style.height = height + 'px';\n                \n                // Update sphere center position on resize\n                const rect = mountRef.current.getBoundingClientRect();\n                sphereCenterRef.current = {\n                    x: rect.left + rect.width / 2,\n                    y: rect.top + rect.height / 2\n                };\n            }, 100);\n        };\n        window.addEventListener('resize', handleResize);\n\n        // Store cleanup function\n        const cleanup = () => {\n            window.removeEventListener('resize', handleResize);\n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n            }\n            if (mountRef.current && renderer && renderer.domElement) {\n                try {\n                    mountRef.current.removeChild(renderer.domElement);\n                } catch (e) {\n                    // Element may have already been removed\n                }\n            }\n            if (renderer) {\n                renderer.dispose();\n            }\n            // Dispose geometries and materials\n            if (textGroupRef.current) {\n                textGroupRef.current.traverse((child) => {\n                    if (child.geometry) child.geometry.dispose();\n                    if (child.material) {\n                        if (Array.isArray(child.material)) {\n                            child.material.forEach(m => {\n                                if (m.map) m.map.dispose();\n                                m.dispose();\n                            });\n                        } else {\n                            if (child.material.map) child.material.map.dispose();\n                            child.material.dispose();\n                        }\n                    }\n                });\n            }\n        };\n        \n        // Return cleanup function\n        return cleanup;\n    }, [text, position, radius, vertexCount, spinSpeed, lightIntensity, lightPosition, fontThickness, threeLoaded]);\n\n    if (error) {\n        return (\n            <div \n                ref={mountRef} \n                style={{ \n                    width: '100%', \n                    height: '100%', \n                    display: 'flex', \n                    alignItems: 'center', \n                    justifyContent: 'center', \n                    color: '#fff',\n                    backgroundColor: 'rgba(0,0,0,0.5)'\n                }}\n            >\n                {error}\n            </div>\n        );\n    }\n\n    if (!threeLoaded) {\n        return (\n            <div \n                ref={mountRef} \n                style={{ \n                    width: '100%', \n                    height: '100%', \n                    display: 'flex', \n                    alignItems: 'center', \n                    justifyContent: 'center', \n                    color: '#fff',\n                    backgroundColor: 'rgba(0,0,0,0.3)'\n                }}\n            >\n                Loading...\n            </div>\n        );\n    }\n\n    // Check if point is within circular area (not bounding box)\n    const isWithinCircle = (mouseX, mouseY, centerX, centerY, circleRadius) => {\n        const dx = mouseX - centerX;\n        const dy = mouseY - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance <= circleRadius;\n    };\n\n    // Calculate proximity-based hover effect using circular detection\n    const calculateProximityHover = (mouseX, mouseY) => {\n        if (!mountRef.current) return;\n        \n        // Update sphere center if container moved\n        const rect = mountRef.current.getBoundingClientRect();\n        const centerX = rect.left + rect.width / 2;\n        const centerY = rect.top + rect.height / 2;\n        sphereCenterRef.current = { x: centerX, y: centerY };\n        \n        // Calculate effective circle radius based on sphere size and container\n        // Use a radius that's proportional to the sphere size, accounting for expansion\n        const maxExpandedRadius = radius * 1.6; // Maximum expansion on hover\n        const circleRadius = maxExpandedRadius * 25; // Convert 3D radius to screen pixels (approximate)\n        \n        // Check if mouse is within the circular area (not the bounding box)\n        const isWithinSphere = isWithinCircle(mouseX, mouseY, centerX, centerY, circleRadius);\n        \n        if (!isWithinSphere) {\n            setIsHovered(false);\n            targetRadius.current = radius;\n            targetCameraDistance.current = Math.max(radius * 3, 15);\n            return;\n        }\n        \n        // Calculate distance from mouse to sphere center\n        const dx = mouseX - centerX;\n        const dy = mouseY - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        // Define proximity threshold based on circle radius\n        const maxDistance = circleRadius; // Full circle radius\n        const minDistance = maxDistance * 0.3; // Start effect at 30% of radius\n        \n        // Calculate proximity factor (0 to 1)\n        let proximityFactor = 0;\n        if (distance < minDistance) {\n            proximityFactor = 1; // Full hover effect\n        } else if (distance < maxDistance) {\n            // Smooth transition from full to no effect\n            proximityFactor = 1 - ((distance - minDistance) / (maxDistance - minDistance));\n        }\n        \n        // Apply hover effects based on proximity\n        if (proximityFactor > 0.1) {\n            setIsHovered(true);\n            // Interpolate expansion based on proximity\n            const expansionAmount = 0.6 * proximityFactor; // Max 1.6x expansion\n            targetRadius.current = radius * (1 + expansionAmount);\n            // Interpolate camera zoom based on proximity\n            const zoomAmount = 0.8 * proximityFactor; // Max 0.8x zoom in\n            targetCameraDistance.current = Math.max(radius * (3 - zoomAmount), 14);\n        } else {\n            setIsHovered(false);\n            // Return to original size\n            targetRadius.current = radius;\n            targetCameraDistance.current = Math.max(radius * 3, 15);\n        }\n    };\n\n    const handleMouseMove = (e) => {\n        mousePositionRef.current = { x: e.clientX, y: e.clientY };\n        calculateProximityHover(e.clientX, e.clientY);\n    };\n\n    const handleMouseLeave = () => {\n        setIsHovered(false);\n        // Return to original size\n        targetRadius.current = radius;\n        targetCameraDistance.current = Math.max(radius * 3, 15);\n    };\n\n    const handleClick = (e) => {\n        if (!link || !mountRef.current) return;\n        \n        // Check if click is within circular area\n        const rect = mountRef.current.getBoundingClientRect();\n        const centerX = rect.left + rect.width / 2;\n        const centerY = rect.top + rect.height / 2;\n        \n        // Calculate effective circle radius\n        const maxExpandedRadius = radius * 1.6;\n        const circleRadius = maxExpandedRadius * 25; // Convert 3D radius to screen pixels\n        \n        // Only navigate if click is within the circle\n        if (isWithinCircle(e.clientX, e.clientY, centerX, centerY, circleRadius)) {\n            navigate(link);\n        }\n    };\n\n    return (\n        <div \n            ref={mountRef} \n            style={{ \n                width: '100%', \n                height: '100%', \n                minHeight: '400px', \n                cursor: isHovered && link ? 'pointer' : 'default',\n                pointerEvents: 'auto', // Ensure it can receive mouse events\n                overflow: 'visible',\n                position: 'relative',\n                zIndex: 1\n            }}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n        >\n            {/* Accessibility tooltip in bottom right */}\n            {isHovered && link && (\n                <div \n                    style={{\n                        position: 'fixed',\n                        bottom: '20px',\n                        right: '20px',\n                        backgroundColor: 'rgba(0, 0, 0, 0.8)',\n                        backdropFilter: 'blur(8px)',\n                        color: '#fff',\n                        padding: '12px 20px',\n                        borderRadius: '8px',\n                        fontSize: '16px',\n                        fontFamily: 'Inter, sans-serif',\n                        fontWeight: 500,\n                        zIndex: 10000,\n                        pointerEvents: 'none',\n                        boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',\n                        transition: 'opacity 0.3s ease',\n                        whiteSpace: 'nowrap'\n                    }}\n                    role=\"tooltip\"\n                    aria-live=\"polite\"\n                >\n                    {text}\n                </div>\n            )}\n        </div>\n    );\n};\n\nexport default TextSphere;\n"],"names":["_ref","text","position","radius","vertexCount","spinSpeed","lightIntensity","lightPosition","fontThickness","link","navigate","useNavigate","mountRef","useRef","animationFrameRef","sceneRef","textGroupRef","cameraRef","threeLoaded","setThreeLoaded","useState","error","setError","isHovered","setIsHovered","THREE_REF","mousePositionRef","x","y","sphereCenterRef","targetCameraDistance","currentCameraDistance","targetRadius","currentRadius","useEffect","then","THREE_MODULE","THREE","default","Scene","current","catch","err","message","renderer","camera","scene","textGroup","directionalLightRef","currentLightIntensity","currentLightPosition","currentFontThickness","initialRadius","initialCameraDistance","Math","max","background","aspect","clientWidth","clientHeight","PerspectiveCamera","cameraDistance","z","lookAt","rect","getBoundingClientRect","left","width","top","height","WebGLRenderer","antialias","alpha","powerPreference","setClearColor","setSize","setPixelRatio","min","window","devicePixelRatio","domElement","style","display","overflow","transform","pointerEvents","maxWidth","maxHeight","appendChild","ambientLight","AmbientLight","add","directionalLight","DirectionalLight","set","pointLight","PointLight","frontLight","Group","createTextSphere","words","split","filter","w","length","totalWords","totalInstances","floor","phi","PI","sqrt","instanceIndex","word","radius_at_y","theta","cos","sin","canvas","document","createElement","context","getContext","fillStyle","fillRect","fontSize","font","concat","textAlign","textBaseline","strokeStyle","lineWidth","strokeText","fillText","texture","CanvasTexture","needsUpdate","segments","planeWidth","planeHeight","geometry","PlaneGeometry","material","MeshStandardMaterial","map","transparent","alphaTest","side","DoubleSide","emissive","metalness","roughness","mesh","Mesh","posX","posY","posZ","userData","isBillboard","initialScale","animate","requestAnimationFrame","cameraLerpSpeed","newDistance","radiusLerpSpeed","scaleFactor","scale","rotation","children","forEach","child","worldPos","Vector3","getWorldPosition","meshWorldPos","textGroupWorldPos","surfaceNormal","subVectors","normalize","lightDirection","negate","lightIntensityFactor","dot","minScale","finalScale","emissiveIntensity","setRGB","render","resizeTimeout","handleResize","clearTimeout","setTimeout","baseWidth","baseHeight","updateProjectionMatrix","addEventListener","cleanup","removeEventListener","cancelAnimationFrame","removeChild","e","dispose","traverse","Array","isArray","m","_jsx","ref","alignItems","justifyContent","color","backgroundColor","isWithinCircle","mouseX","mouseY","centerX","centerY","circleRadius","dx","dy","minHeight","cursor","zIndex","onMouseMove","clientX","clientY","calculateProximityHover","distance","minDistance","proximityFactor","expansionAmount","zoomAmount","onMouseLeave","handleMouseLeave","onClick","bottom","right","backdropFilter","padding","borderRadius","fontFamily","fontWeight","boxShadow","transition","whiteSpace","role"],"sourceRoot":""}