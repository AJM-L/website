{"version":3,"file":"static/js/501.f1199568.chunk.js","mappings":"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","sources":["components/About/TextSphere.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst TextSphere = ({ \n    text, \n    position = [0, 0, 0],\n    radius = 5,\n    vertexCount = 50,\n    spinSpeed = 0.005,\n    lightIntensity = 1.0,\n    lightPosition = [10, 10, 10],\n    fontThickness = 0.1,\n    link = null // Optional link to navigate to\n}) => {\n    const navigate = useNavigate();\n    const mountRef = useRef(null);\n    const animationFrameRef = useRef(null);\n    const sceneRef = useRef(null);\n    const textGroupRef = useRef(null);\n    const cameraRef = useRef(null);\n    const [threeLoaded, setThreeLoaded] = useState(false);\n    const [error, setError] = useState(null);\n    const [isHovered, setIsHovered] = useState(false);\n    const THREE_REF = useRef(null);\n    \n    // Animation targets for smooth transitions\n    const targetCameraDistance = useRef(radius * 3);\n    const currentCameraDistance = useRef(radius * 3);\n    const targetRadius = useRef(radius);\n    const currentRadius = useRef(radius);\n\n    useEffect(() => {\n        // Dynamically import three.js to avoid build-time processing\n        import('three').then((THREE_MODULE) => {\n            // Handle different export formats\n            const THREE = THREE_MODULE.default || THREE_MODULE;\n            if (THREE && THREE.Scene) {\n                THREE_REF.current = THREE;\n                setThreeLoaded(true);\n            } else {\n                setError('Failed to load Three.js module');\n            }\n        }).catch((err) => {\n            setError('Failed to load Three.js - ' + err.message);\n        });\n    }, []);\n\n    useEffect(() => {\n        if (!threeLoaded || !THREE_REF.current || !mountRef.current) {\n            return;\n        }\n        \n        const THREE = THREE_REF.current;\n        if (!mountRef.current || !THREE) {\n            return;\n        }\n        \n        let renderer = null;\n        let camera = null;\n        let scene = null;\n        let textGroup = null;\n        let directionalLightRef = null;\n        // Store lighting parameters for animation loop\n        const currentLightIntensity = lightIntensity;\n        const currentLightPosition = [...lightPosition];\n        const currentFontThickness = fontThickness;\n        // Store initial values for hover animation\n        const initialRadius = radius;\n        const initialCameraDistance = Math.max(radius * 3, 15);\n\n        // Scene setup\n        scene = new THREE.Scene();\n        scene.background = null; // Transparent background\n        sceneRef.current = scene;\n\n        const aspect = mountRef.current.clientWidth / mountRef.current.clientHeight || 1;\n        camera = new THREE.PerspectiveCamera(\n            75,\n            aspect,\n            0.1,\n            1000\n        );\n        // Position camera to view the sphere - make sure it's far enough back\n        // Position camera to look at the textGroup position\n        const cameraDistance = initialCameraDistance;\n        currentCameraDistance.current = cameraDistance;\n        targetCameraDistance.current = cameraDistance;\n        camera.position.z = position[2] + cameraDistance;\n        camera.position.y = position[1];\n        camera.position.x = position[0];\n        camera.lookAt(position[0], position[1], position[2]);\n        cameraRef.current = camera;\n\n        renderer = new THREE.WebGLRenderer({ \n            antialias: true, \n            alpha: true,\n            powerPreference: \"high-performance\"\n        });\n        renderer.setClearColor(0x000000, 0); // Transparent background\n        // Use container size - canvas should match container to avoid scaling issues\n        const baseWidth = mountRef.current.clientWidth || 600;\n        const baseHeight = mountRef.current.clientHeight || 600;\n        // Canvas matches container size - container is already sized for expansion\n        const width = baseWidth;\n        const height = baseHeight;\n        renderer.setSize(width, height);\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Lower pixel ratio for better performance\n        \n        // Make sure canvas is visible and can overflow - center it in container\n        renderer.domElement.style.width = width + 'px';\n        renderer.domElement.style.height = height + 'px';\n        renderer.domElement.style.display = 'block';\n        renderer.domElement.style.overflow = 'visible';\n        renderer.domElement.style.position = 'absolute';\n        renderer.domElement.style.top = '50%';\n        renderer.domElement.style.left = '50%';\n        renderer.domElement.style.transform = 'translate(-50%, -50%)';\n        renderer.domElement.style.pointerEvents = 'auto';\n        renderer.domElement.style.maxWidth = 'none';\n        renderer.domElement.style.maxHeight = 'none';\n        \n        if (mountRef.current) {\n            mountRef.current.appendChild(renderer.domElement);\n        }\n\n        // Lighting setup for diffuse lighting - reduce ambient to make directional light more visible\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);\n        scene.add(ambientLight);\n\n        const directionalLight = new THREE.DirectionalLight(\n            0xffffff, \n            lightIntensity * 2.0\n        );\n        directionalLight.position.set(...lightPosition);\n        scene.add(directionalLight);\n        directionalLightRef = directionalLight; // Store reference for animation loop\n\n        // Add a point light for more dynamic lighting\n        const pointLight = new THREE.PointLight(0xffffff, 1.5);\n        pointLight.position.set(5, 5, 5);\n        scene.add(pointLight);\n        \n        // Add another light from the front\n        const frontLight = new THREE.DirectionalLight(0xffffff, 1.2);\n        frontLight.position.set(0, 0, 10);\n        scene.add(frontLight);\n\n        // Create text group\n        textGroup = new THREE.Group();\n        textGroupRef.current = textGroup;\n        currentRadius.current = initialRadius;\n        targetRadius.current = initialRadius;\n\n        // Create text using canvas and position words in sphere pattern\n        const createTextSphere = () => {\n            // Split text into words\n            const words = text.split(' ').filter(w => w.length > 0);\n            const totalWords = words.length;\n            \n            if (totalWords === 0) return;\n            \n            // Repeat the phrase multiple times to fill the sphere\n            // Calculate how many instances we need based on desired density\n            const instancesPerWord = Math.max(10, Math.floor(100 / totalWords)); // More instances for fewer words\n            const totalInstances = totalWords * instancesPerWord;\n            \n            // Use Fibonacci sphere distribution for even spacing\n            const phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle\n            \n            // Create instances of each word distributed around the sphere\n            for (let instanceIndex = 0; instanceIndex < totalInstances; instanceIndex++) {\n                // Cycle through words\n                const wordIndex = instanceIndex % totalWords;\n                const word = words[wordIndex];\n                \n                // Calculate position on sphere for each instance\n                const y = 1 - (instanceIndex / (totalInstances - 1)) * 2; // y from 1 to -1\n                const radius_at_y = Math.sqrt(Math.max(0, 1 - y * y));\n                const theta = phi * instanceIndex;\n                \n                const x = Math.cos(theta) * radius_at_y;\n                const z = Math.sin(theta) * radius_at_y;\n                \n                // Create canvas for entire word\n                const canvas = document.createElement('canvas');\n                const context = canvas.getContext('2d');\n                canvas.width = 512;\n                canvas.height = 512;\n                \n                // Fill with transparent background\n                context.fillStyle = 'rgba(0, 0, 0, 0)';\n                context.fillRect(0, 0, canvas.width, canvas.height);\n                \n                // Draw word - make it larger and more visible with high contrast\n                const fontSize = Math.max(100, Math.min(180, 500 / word.length));\n                context.fillStyle = '#ffffff';\n                context.font = `Bold ${fontSize}px Arial`;\n                context.textAlign = 'center';\n                context.textBaseline = 'middle';\n                // Strong black stroke for high contrast\n                context.strokeStyle = '#000000';\n                context.lineWidth = 5;\n                context.strokeText(word, 256, 256);\n                context.fillText(word, 256, 256);\n                \n                // Create texture from canvas\n                const texture = new THREE.CanvasTexture(canvas);\n                texture.needsUpdate = true;\n                \n                // Create plane geometry for each word with vertex count control\n                const segments = Math.max(1, Math.floor(Math.sqrt(vertexCount)));\n                // Make planes larger for better visibility - scale based on radius and word length\n                const planeWidth = Math.max(radius * 0.7, word.length * 0.4);\n                const planeHeight = radius * 0.6;\n                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight, segments, segments);\n                \n                // Create material with diffuse lighting and high contrast\n                // The lighting will affect how thick the text appears\n                const material = new THREE.MeshStandardMaterial({\n                    map: texture,\n                    transparent: true,\n                    alphaTest: 0.05, // Discard pixels with low alpha\n                    side: THREE.DoubleSide, // Render both sides\n                    emissive: 0x444444, // Increased emission for better visibility\n                    metalness: 0.0,\n                    roughness: 0.5\n                });\n                \n                const mesh = new THREE.Mesh(geometry, material);\n                \n                // Position on sphere\n                const posX = x * radius;\n                const posY = y * radius;\n                const posZ = z * radius;\n                mesh.position.set(posX, posY, posZ);\n                \n                // Store reference to camera for billboard effect\n                mesh.userData.isBillboard = true;\n                // Store initial scale for lighting-based scaling\n                mesh.userData.initialScale = { x: 1, y: 1, z: 1 };\n                \n                textGroup.add(mesh);\n            }\n        };\n\n        // Use canvas method immediately (no external resources needed)\n        createTextSphere();\n\n        textGroup.position.set(...position);\n        scene.add(textGroup);\n\n        // Animation loop\n        const animate = () => {\n            animationFrameRef.current = requestAnimationFrame(animate);\n            \n            if (textGroupRef.current && camera && scene) {\n                // Smooth camera distance transition on hover\n                const cameraLerpSpeed = 0.1;\n                currentCameraDistance.current += (targetCameraDistance.current - currentCameraDistance.current) * cameraLerpSpeed;\n                \n                // Update camera position based on hover state\n                if (cameraRef.current) {\n                    const newDistance = currentCameraDistance.current;\n                    cameraRef.current.position.z = position[2] + newDistance;\n                    cameraRef.current.position.y = position[1];\n                    cameraRef.current.position.x = position[0];\n                    cameraRef.current.lookAt(position[0], position[1], position[2]);\n                }\n                \n                // Smooth radius transition on hover\n                const radiusLerpSpeed = 0.1;\n                currentRadius.current += (targetRadius.current - currentRadius.current) * radiusLerpSpeed;\n                \n                // Scale the entire text group based on hover\n                const scaleFactor = currentRadius.current / initialRadius;\n                textGroupRef.current.scale.set(scaleFactor, scaleFactor, scaleFactor);\n                \n                // Rotate the entire group\n                textGroupRef.current.rotation.y += spinSpeed;\n                textGroupRef.current.rotation.x += spinSpeed * 0.5;\n                \n                // Make each word face the camera and scale based on lighting\n                textGroupRef.current.children.forEach((child) => {\n                    if (child.userData.isBillboard) {\n                        // Get world position of the mesh\n                        const worldPos = new THREE.Vector3();\n                        child.getWorldPosition(worldPos);\n                        \n                        // Make the mesh look at the camera\n                        child.lookAt(camera.position);\n                        \n                        // Calculate lighting intensity at this position based on sphere surface\n                        // Get the direction from sphere center to mesh (surface normal)\n                        const meshWorldPos = new THREE.Vector3();\n                        child.getWorldPosition(meshWorldPos);\n                        const textGroupWorldPos = new THREE.Vector3();\n                        textGroupRef.current.getWorldPosition(textGroupWorldPos);\n                        \n                        // Surface normal points from sphere center to mesh\n                        const surfaceNormal = new THREE.Vector3()\n                            .subVectors(meshWorldPos, textGroupWorldPos)\n                            .normalize();\n                        \n                        // For directional light, the direction is the negative of the position\n                        // Directional lights shine in the direction opposite to their position\n                        const lightDirection = new THREE.Vector3(...currentLightPosition).normalize().negate();\n                        \n                        // Calculate dot product (how much the surface faces the light)\n                        // Positive = facing light, negative = facing away\n                        const lightIntensityFactor = Math.max(0, Math.min(1, surfaceNormal.dot(lightDirection)));\n                        \n                        // Scale based on light intensity - brighter areas = larger text\n                        // Make the effect more pronounced with a wider range\n                        const minScale = 0.2; // Minimum scale for shadowed areas\n                        const maxScale = 4; // Maximum scale for fully lit areas\n                        const scaleRange = maxScale - minScale;\n                        const finalScale = minScale + (lightIntensityFactor * scaleRange * currentLightIntensity * currentFontThickness);\n                        \n                        // Apply scale to make text appear thicker where lit\n                        child.scale.set(finalScale, finalScale, 1);\n                        \n                        // Also adjust material emissive based on lighting for color variation\n                        if (child.material && child.material.emissive) {\n                            const emissiveIntensity = lightIntensityFactor * 0.3;\n                            child.material.emissive.setRGB(emissiveIntensity, emissiveIntensity, emissiveIntensity);\n                        }\n                    }\n                });\n            }\n            \n            if (renderer && scene && camera) {\n                renderer.render(scene, camera);\n            }\n        };\n        animate();\n\n        // Handle resize - canvas matches container size with debouncing for performance\n        let resizeTimeout;\n        const handleResize = () => {\n            if (!mountRef.current || !camera || !renderer) return;\n            clearTimeout(resizeTimeout);\n            resizeTimeout = setTimeout(() => {\n                const baseWidth = mountRef.current.clientWidth || 600;\n                const baseHeight = mountRef.current.clientHeight || 600;\n                const width = baseWidth;\n                const height = baseHeight;\n                camera.aspect = (baseWidth / baseHeight);\n                camera.updateProjectionMatrix();\n                renderer.setSize(width, height);\n                renderer.domElement.style.width = width + 'px';\n                renderer.domElement.style.height = height + 'px';\n            }, 100);\n        };\n        window.addEventListener('resize', handleResize);\n\n        // Store cleanup function\n        const cleanup = () => {\n            window.removeEventListener('resize', handleResize);\n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n            }\n            if (mountRef.current && renderer && renderer.domElement) {\n                try {\n                    mountRef.current.removeChild(renderer.domElement);\n                } catch (e) {\n                    // Element may have already been removed\n                }\n            }\n            if (renderer) {\n                renderer.dispose();\n            }\n            // Dispose geometries and materials\n            if (textGroupRef.current) {\n                textGroupRef.current.traverse((child) => {\n                    if (child.geometry) child.geometry.dispose();\n                    if (child.material) {\n                        if (Array.isArray(child.material)) {\n                            child.material.forEach(m => {\n                                if (m.map) m.map.dispose();\n                                m.dispose();\n                            });\n                        } else {\n                            if (child.material.map) child.material.map.dispose();\n                            child.material.dispose();\n                        }\n                    }\n                });\n            }\n        };\n        \n        // Return cleanup function\n        return cleanup;\n    }, [text, position, radius, vertexCount, spinSpeed, lightIntensity, lightPosition, fontThickness, threeLoaded]);\n\n    if (error) {\n        return (\n            <div \n                ref={mountRef} \n                style={{ \n                    width: '100%', \n                    height: '100%', \n                    display: 'flex', \n                    alignItems: 'center', \n                    justifyContent: 'center', \n                    color: '#fff',\n                    backgroundColor: 'rgba(0,0,0,0.5)'\n                }}\n            >\n                {error}\n            </div>\n        );\n    }\n\n    if (!threeLoaded) {\n        return (\n            <div \n                ref={mountRef} \n                style={{ \n                    width: '100%', \n                    height: '100%', \n                    display: 'flex', \n                    alignItems: 'center', \n                    justifyContent: 'center', \n                    color: '#fff',\n                    backgroundColor: 'rgba(0,0,0,0.3)'\n                }}\n            >\n                Loading...\n            </div>\n        );\n    }\n\n    const handleMouseEnter = () => {\n        setIsHovered(true);\n        // Expand sphere but keep camera distance reasonable to stay in container\n        targetRadius.current = radius * 1.8;\n        targetCameraDistance.current = Math.max(radius * 2.0, 12);\n    };\n\n    const handleMouseLeave = () => {\n        setIsHovered(false);\n        // Return to original size\n        targetRadius.current = radius;\n        targetCameraDistance.current = Math.max(radius * 3, 15);\n    };\n\n    const handleClick = () => {\n        if (link) {\n            navigate(link);\n        }\n    };\n\n    return (\n        <div \n            ref={mountRef} \n            style={{ \n                width: '100%', \n                height: '100%', \n                minHeight: '400px', \n                cursor: link ? 'pointer' : 'default',\n                overflow: 'visible',\n                position: 'relative',\n                zIndex: 1\n            }}\n            onMouseEnter={handleMouseEnter}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n        />\n    );\n};\n\nexport default TextSphere;\n"],"names":["_ref","text","position","radius","vertexCount","spinSpeed","lightIntensity","lightPosition","fontThickness","link","navigate","useNavigate","mountRef","useRef","animationFrameRef","sceneRef","textGroupRef","cameraRef","threeLoaded","setThreeLoaded","useState","error","setError","isHovered","setIsHovered","THREE_REF","targetCameraDistance","currentCameraDistance","targetRadius","currentRadius","useEffect","then","THREE_MODULE","THREE","default","Scene","current","catch","err","message","renderer","camera","scene","textGroup","directionalLightRef","currentLightIntensity","currentLightPosition","currentFontThickness","initialRadius","initialCameraDistance","Math","max","background","aspect","clientWidth","clientHeight","PerspectiveCamera","cameraDistance","z","y","x","lookAt","WebGLRenderer","antialias","alpha","powerPreference","setClearColor","width","height","setSize","setPixelRatio","min","window","devicePixelRatio","domElement","style","display","overflow","top","left","transform","pointerEvents","maxWidth","maxHeight","appendChild","ambientLight","AmbientLight","add","directionalLight","DirectionalLight","set","pointLight","PointLight","frontLight","Group","createTextSphere","words","split","filter","w","length","totalWords","totalInstances","floor","phi","PI","sqrt","instanceIndex","word","radius_at_y","theta","cos","sin","canvas","document","createElement","context","getContext","fillStyle","fillRect","fontSize","font","concat","textAlign","textBaseline","strokeStyle","lineWidth","strokeText","fillText","texture","CanvasTexture","needsUpdate","segments","planeWidth","planeHeight","geometry","PlaneGeometry","material","MeshStandardMaterial","map","transparent","alphaTest","side","DoubleSide","emissive","metalness","roughness","mesh","Mesh","posX","posY","posZ","userData","isBillboard","initialScale","animate","requestAnimationFrame","cameraLerpSpeed","newDistance","radiusLerpSpeed","scaleFactor","scale","rotation","children","forEach","child","worldPos","Vector3","getWorldPosition","meshWorldPos","textGroupWorldPos","surfaceNormal","subVectors","normalize","lightDirection","negate","lightIntensityFactor","dot","minScale","finalScale","emissiveIntensity","setRGB","render","resizeTimeout","handleResize","clearTimeout","setTimeout","baseWidth","baseHeight","updateProjectionMatrix","addEventListener","cleanup","removeEventListener","cancelAnimationFrame","removeChild","e","dispose","traverse","Array","isArray","m","_jsx","ref","alignItems","justifyContent","color","backgroundColor","minHeight","cursor","zIndex","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onClick","handleClick"],"sourceRoot":""}